---
layout:     post
title:      Procedure vs. Process in Computer System Perspective
subtitle:   sicp notes
date:       2019-12-10
author:     Sudo
header-img: img/post-bg-car.jpg
catalog:    true
tags:
    - LISP
    - sicp
---

> All code written in LISP

# What are Process and Procedure?  

A procedure is a **pattern** of *local evolution* of a computational process. It specifies how each stage of the process is built upon on previous stage. The significant word here is **PARTERN**, a procedure is a general pattern, and process is a series of action generated by a certain procedure.   
Take a very simple example, assuming there is a black box whose function is to compute the sum of two numbers. And I give two input(e.g., 1, 2) to that black box, in this case, black-box is just the **procedure**, its pattern is to add two numbers up and output the result. The process generated by the procedure is *1+2 and return 3*.


# Linear Recursion and Iteration

## Recurisive Process

Considering the factorial function, defined by  

n! = n · (n − 1) · (n − 2) · · · 3 · 2 · 1  

There are many ways to compute factorials. One way is to make use of the observation that n! is equal to n times (n − 1)! for any positive integer n:  

n! = n · [(n − 1) · (n − 2) · · · 3 · 2 · 1] = n · (n − 1)!

Thus, we can compute n! by computing (n − 1)! and multiplying the result by n. If we add the stipulation that 1! is equal to 1, this observation translates directly into a procedure:  

```LISP
 (define (factorial n)
   (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

![linear Recurisive process](https://tva1.sinaimg.cn/large/006tNbRwgy1ga7o1q6nc8j313k0p0aeg.jpg)  



## Iterative Process
We could also describe a rule for computing n! by specifying that we first mul- tiply 1 by 2, then multiply the result by 3, then by 4, and so on until we reach n. More formally, we maintain a running product, together with a counter that counts from 1 up to n. We can describe the computation by saying that the counter and the product simultaneously change from one step to the next according to the rule  
product ← counter * product  
counter ← counter + 1  
and stipulating that n! is the value of the product when the counter exceeds n.

```LISP
(define (factorial n)
   (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```

![iterative process](https://tva1.sinaimg.cn/large/006tNbRwgy1ga7o6ordlkj30yq0jg41b.jpg)  


## Compare Recurisive with Iterative Methods

- Recurisive process takes O(n) time complexity as well as O(n) space complexity
- Iterative Process takes O(n) time complexity, but O(1) space complexity.

Even though the two processes carry out the same output, but they are quiet different when we consider the "shape" of the two processes.

# Notion of *Recursive* Procedure and *Recursive* Process  

we must be careful not to confuse the notion of a *recursive* process with the notion of a recursive *procedure*. When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers (either directly or indirectly) to the procedure itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a procedure is written. It may seem disturbing that we refer to a recursive procedure such as *fact-iter* as generating an iterative process. However, the pro- cess really is iterative: Its state is captured completely by its three state variables, and an interpreter need keep track of only three variables in order to execute the process. Both of two procedures are recursive, since *fact-iter* is called recursively. But only the former one is recursive process, the program needs to use extra space to track extra information, until the process reaches an edge case. The second one is just iterative process.  
